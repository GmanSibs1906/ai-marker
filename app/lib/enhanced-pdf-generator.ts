import jsPDF from 'jspdf';

export interface PDFGenerationOptions {
  studentName: string;
  assignmentTitle: string;
  markingContent: string;
  totalMarks: number;
  percentage: number;
  includeLogo?: boolean;
  logoPath?: string;
  institutionName?: string;
}

// Function to load image as base64
async function loadImageAsBase64(imagePath: string): Promise<string | null> {
  try {
    // In browser environment, we need to fetch the image
    const response = await fetch(imagePath);
    const blob = await response.blob();
    
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = () => resolve(null);
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.warn('Could not load image:', error);
    return null;
  }
}

export async function generateEnhancedPDFWithLogo(options: PDFGenerationOptions): Promise<jsPDF> {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  const margin = 20;
  const maxWidth = pageWidth - 2 * margin;
  let yPosition = margin;

  // Add logo if provided
  if (options.includeLogo && options.logoPath) {
    try {
      const logoBase64 = await loadImageAsBase64(options.logoPath);
             if (logoBase64) {
                 // Add the actual logo with better proportions
        const logoWidth = 25;
        const logoHeight = 27; // Reduced by 5px from 30 to 25
        doc.addImage(logoBase64, 'PNG', margin, yPosition, logoWidth, logoHeight);
        
        // Add institution name next to logo
        doc.setFontSize(16);
        doc.setFont('times', 'bold'); // Using times as fallback since Red Hat Display not available in jsPDF
        doc.setTextColor(25, 25, 112); // Navy blue
        doc.text('MELSOFT ACADEMY', margin + logoWidth + 10, yPosition + 15);
        yPosition += logoHeight + 10;
      } else {
        // Fallback to text logo
        doc.setFontSize(16);
        doc.setFont('times', 'bold');
        doc.setTextColor(25, 25, 112);
        doc.text('MELSOFT ACADEMY', margin, yPosition);
        yPosition += 20;
      }
    } catch (error) {
      console.warn('Error loading logo:', error);
      // Fallback to text logo
      doc.setFontSize(16);
      doc.setFont('times', 'bold');
      doc.setTextColor(25, 25, 112);
      doc.text('MELSOFT ACADEMY', margin, yPosition);
      yPosition += 20;
    }
  } else {
    // Default text header
    doc.setFontSize(16);
    doc.setFont('times', 'bold');
    doc.setTextColor(25, 25, 112);
    doc.text('MELSOFT ACADEMY', margin, yPosition);
    yPosition += 20;
  }

  // Main title
  doc.setFontSize(20);
  doc.setFont('times', 'bold');
  doc.setTextColor(0, 0, 0);
  const headerText = 'Assessment Marking Results';
  const headerWidth = doc.getTextWidth(headerText);
  doc.text(headerText, (pageWidth - headerWidth) / 2, yPosition);
  yPosition += 15;

  // Institution subtitle
  doc.setFontSize(12);
  doc.setFont('times', 'normal');
  doc.setTextColor(100, 100, 100);
  const subtitleText = 'Melsoft Academy - AI Assessment Marker';
  const subtitleWidth = doc.getTextWidth(subtitleText);
  doc.text(subtitleText, (pageWidth - subtitleWidth) / 2, yPosition);
  yPosition += 25;

  // Student information section
  doc.setFontSize(11);
  doc.setFont('times', 'normal');
  doc.setTextColor(0, 0, 0);
  
  doc.text(`Student: ${options.studentName}`, margin, yPosition);
  yPosition += 8;
  doc.text(`Assignment: ${options.assignmentTitle}`, margin, yPosition);
  yPosition += 8;
  doc.text(`Date Marked: ${new Date().toLocaleDateString('en-GB')}`, margin, yPosition);
  yPosition += 15;
  
  // Final score highlight box
  doc.setFillColor(240, 248, 255); // Light blue background
  doc.rect(margin, yPosition - 5, maxWidth, 20, 'F');
  doc.setFontSize(14);
  doc.setFont('times', 'bold');
  doc.setTextColor(0, 100, 0); // Green color
  doc.text(`Final Score: ${options.totalMarks} marks (${options.percentage}%)`, margin + 5, yPosition + 8);
  yPosition += 25;

  // Process the content and clean it up
  const cleanedContent = cleanMarkingContent(options.markingContent);
  const sections = parseContentSections(cleanedContent);

  // Render each section
  for (const section of sections) {
    yPosition = await renderSection(doc, section, margin, maxWidth, pageWidth, pageHeight, yPosition);
  }

  // Add professional footer to all pages
  const totalPages = doc.internal.pages.length - 1;
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    
    // Footer line
    doc.setDrawColor(200, 200, 200);
    doc.line(margin, pageHeight - 25, pageWidth - margin, pageHeight - 25);
    
    // Footer text
    doc.setFontSize(8);
    doc.setTextColor(100, 100, 100);
    doc.text('Generated by Melsoft Academy - AI Assessment Marker', margin, pageHeight - 15);
    doc.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 25, pageHeight - 15);
  }

  return doc;
}

function cleanMarkingContent(content: string): string {
  // Remove any remaining technical messages
  let cleaned = content.replace(/\*This assessment was marked using.*?\*$/gm, '');
  
  // Remove ALL emojis as they don't display properly in PDF
  cleaned = cleaned.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');
  
  // Clean up markdown formatting for better PDF rendering
  cleaned = cleaned.replace(/\*\*(.*?)\*\*/g, '$1'); // Remove bold markdown
  cleaned = cleaned.replace(/\*(.*?)\*/g, '$1'); // Remove italic markdown
  
  // Remove excessive newlines
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  return cleaned.trim();
}

interface ContentSection {
  type: 'header' | 'subheader' | 'table' | 'text' | 'list' | 'feedback';
  content: string;
  level?: number;
}

function parseContentSections(content: string): ContentSection[] {
  const lines = content.split('\n');
  const sections: ContentSection[] = [];
  let currentTable: string[] = [];
  let inTable = false;

  for (const line of lines) {
    const trimmedLine = line.trim();
    
    if (!trimmedLine) {
      if (inTable && currentTable.length > 0) {
        sections.push({
          type: 'table',
          content: currentTable.join('\n')
        });
        currentTable = [];
        inTable = false;
      }
      continue;
    }

    // Check for headers with emojis
    if (trimmedLine.startsWith('### ')) {
      if (inTable && currentTable.length > 0) {
        sections.push({
          type: 'table',
          content: currentTable.join('\n')
        });
        currentTable = [];
        inTable = false;
      }
      
      const headerText = trimmedLine.replace('### ', '');
      if (headerText.includes('Feedback') || headerText.includes('Encouragement')) {
        sections.push({
          type: 'feedback',
          content: headerText,
          level: 1
        });
      } else {
        sections.push({
          type: 'header',
          content: headerText,
          level: 1
        });
      }
    }
    // Check for table rows
    else if (trimmedLine.startsWith('|') && trimmedLine.endsWith('|')) {
      if (!inTable) {
        inTable = true;
      }
      if (!trimmedLine.includes('---')) {
        currentTable.push(trimmedLine);
      }
    }
    // Check for horizontal lines
    else if (trimmedLine.startsWith('---')) {
      if (inTable && currentTable.length > 0) {
        sections.push({
          type: 'table',
          content: currentTable.join('\n')
        });
        currentTable = [];
        inTable = false;
      }
      // Skip horizontal lines in PDF
    }
    // Check for lists
    else if (trimmedLine.startsWith('•') || trimmedLine.startsWith('*')) {
      if (inTable && currentTable.length > 0) {
        sections.push({
          type: 'table',
          content: currentTable.join('\n')
        });
        currentTable = [];
        inTable = false;
      }
      sections.push({
        type: 'list',
        content: trimmedLine.replace(/^[•*]\s*/, '• ')
      });
    }
    // Regular text
    else {
      if (inTable && currentTable.length > 0) {
        sections.push({
          type: 'table',
          content: currentTable.join('\n')
        });
        currentTable = [];
        inTable = false;
      }
      if (trimmedLine.length > 0) {
        sections.push({
          type: 'text',
          content: trimmedLine
        });
      }
    }
  }

  // Handle any remaining table
  if (inTable && currentTable.length > 0) {
    sections.push({
      type: 'table',
      content: currentTable.join('\n')
    });
  }

  return sections;
}

async function renderSection(
  doc: jsPDF, 
  section: ContentSection, 
  margin: number, 
  maxWidth: number, 
  pageWidth: number, 
  pageHeight: number, 
  yPosition: number
): Promise<number> {
  // Check if we need a new page
  if (yPosition > pageHeight - 40) {
    doc.addPage();
    yPosition = margin;
  }

  switch (section.type) {
    case 'header':
      doc.setFontSize(14);
      doc.setFont('times', 'bold');
      doc.setTextColor(25, 25, 112); // Navy blue
      doc.text(section.content, margin, yPosition);
      yPosition += 15;
      break;

    case 'feedback':
      doc.setFontSize(14);
      doc.setFont('times', 'bold');
      doc.setTextColor(0, 150, 0); // Green for feedback
      doc.text(section.content, margin, yPosition);
      yPosition += 15;
      break;

    case 'subheader':
      doc.setFontSize(12);
      doc.setFont('times', 'bold');
      doc.setTextColor(0, 0, 0);
      doc.text(section.content, margin, yPosition);
      yPosition += 12;
      break;

    case 'table':
      yPosition = await renderTable(doc, section.content, margin, maxWidth, pageWidth, pageHeight, yPosition);
      break;

    case 'list':
      doc.setFontSize(10);
      doc.setFont('times', 'normal');
      doc.setTextColor(0, 0, 0);
      const listLines = doc.splitTextToSize(section.content, maxWidth - 10);
      doc.text(listLines, margin + 5, yPosition);
      yPosition += listLines.length * 5 + 2;
      break;

    case 'text':
      doc.setFontSize(10);
      doc.setFont('times', 'normal');
      doc.setTextColor(0, 0, 0);
      
      // Handle bold text in feedback sections
      const content = section.content;
      if (content.includes('**')) {
        const parts = content.split('**');
        let currentX = margin;
        
        for (let i = 0; i < parts.length; i++) {
          if (i % 2 === 1) {
            // Bold text
            doc.setFont('times', 'bold');
          } else {
            // Normal text
            doc.setFont('times', 'normal');
          }
          
          if (parts[i].trim()) {
            const textLines = doc.splitTextToSize(parts[i], maxWidth - (currentX - margin));
            doc.text(textLines, currentX, yPosition);
            if (textLines.length > 1) {
              yPosition += (textLines.length - 1) * 5;
            }
            currentX += doc.getTextWidth(parts[i]);
          }
        }
        yPosition += 8;
      } else {
        const textLines = doc.splitTextToSize(content, maxWidth);
        doc.text(textLines, margin, yPosition);
        yPosition += textLines.length * 5 + 3;
      }
      break;
  }

  return yPosition;
}

async function renderTable(
  doc: jsPDF,
  tableContent: string,
  margin: number,
  maxWidth: number,
  pageWidth: number,
  pageHeight: number,
  yPosition: number
): Promise<number> {
  const rows = tableContent.split('\n').filter(row => row.trim());
  
  if (rows.length === 0) return yPosition;

  const isHeaderRow = (row: string) => {
    return row.includes('Topic') && row.includes('Mark') && !row.includes('Item');
  };

  // Calculate column widths - 2 columns: Topic, Mark
  const colWidths = [140, 50]; // Topic, Mark
  const totalTableWidth = colWidths.reduce((sum, width) => sum + width, 0);
  const startX = margin + (maxWidth - totalTableWidth) / 2;

  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    const row = rows[rowIndex];
    
    // Check if we need a new page
    if (yPosition > pageHeight - 30) {
      doc.addPage();
      yPosition = margin + 10;
    }

    const cells = row.split('|').map(cell => cell.trim()).filter(cell => cell);
    
    if (cells.length >= 2) {
      let currentX = startX;
      
      // Set formatting for header or data rows
      if (isHeaderRow(row)) {
        doc.setFont('times', 'bold');
        doc.setFontSize(10);
        doc.setTextColor(0, 0, 0);
        
        // Draw header background
        doc.setFillColor(240, 240, 240);
        doc.rect(startX, yPosition - 8, totalTableWidth, 12, 'F');
        
        // Custom header labels for 2-column layout
        doc.text('Topic', currentX + 2, yPosition - 2);
        currentX += colWidths[0];
        doc.text('Mark', currentX + 2, yPosition - 2);
      } else {
        doc.setFont('times', 'normal');
        doc.setFontSize(9);
        doc.setTextColor(0, 0, 0);
        
        // Process data rows - 2 columns: Topic, Mark
        colWidths.forEach((width, colIndex) => {
          // Draw cell border
          doc.setDrawColor(200, 200, 200);
          doc.rect(currentX, yPosition - 8, width, 12);
          
          let cellText = '';
          if (colIndex === 0 && cells[0]) {
            // Topic column
            cellText = cells[0].length > 40 ? cells[0].substring(0, 37) + '...' : cells[0];
          } else if (colIndex === 1 && cells[1]) {
            // Mark column (already combined as "5/5" format)
            cellText = cells[1];
          }
          
          if (cellText) {
            doc.text(cellText, currentX + 2, yPosition - 2);
          }
          currentX += width;
        });
      }
      
      // Draw borders for all cells
      currentX = startX;
      colWidths.forEach((width) => {
        doc.setDrawColor(200, 200, 200);
        doc.rect(currentX, yPosition - 8, width, 12);
        currentX += width;
      });
      
      yPosition += 12;
    }
  }

  return yPosition + 10;
}

export function downloadEnhancedPDF(
  options: PDFGenerationOptions,
  filename?: string
): void {
  // Create a basic PDF for backward compatibility
  const doc = new jsPDF();
  doc.text('Basic PDF - Use downloadEnhancedPDFWithLogo for full features', 20, 20);
  const defaultFilename = `MARKED_${options.studentName}_${options.assignmentTitle}.pdf`;
  doc.save(filename || defaultFilename);
}

export async function downloadEnhancedPDFWithLogo(
  options: PDFGenerationOptions,
  filename?: string
): Promise<void> {
  const doc = await generateEnhancedPDFWithLogo(options);
  const defaultFilename = `MARKED_${options.studentName}_${options.assignmentTitle}.pdf`;
  doc.save(filename || defaultFilename);
}

// Add logo to public folder helper
export function addLogoToPDF(doc: jsPDF, logoUrl: string, x: number, y: number, width: number, height: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function() {
      try {
        // Convert image to data URL and add to PDF
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (ctx) {
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          const dataURL = canvas.toDataURL('image/jpeg', 0.8);
          doc.addImage(dataURL, 'JPEG', x, y, width, height);
        }
        resolve();
      } catch (error) {
        reject(error);
      }
    };
    img.onerror = reject;
    img.src = logoUrl;
  });
} 